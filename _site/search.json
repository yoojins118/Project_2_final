{
  "articles": [
    {
      "path": "about.html",
      "title": "About this site",
      "description": "Some additional details about the website",
      "author": [],
      "contents": "\n\n\n\n",
      "last_modified": "2021-10-30T22:33:59+08:00"
    },
    {
      "path": "index.html",
      "title": "Tidy Challenge 2",
      "description": "A new article created using the Distill format for Tidy Challenge 2 - Singapore Case Study \n",
      "author": [],
      "contents": "\nIntroduction\nAbout Data\nCreating 2 additional paths, path_data and path_xls, from the working directory.\nLoading packages\nImported Packages:\nThe tidyxl package imports non-tabular data from Excel files into R. It exposes cell content, position, formatting and comments in a tidy structure for further manipulation, especially by the unpivotor package.\nThe unpivtor package is used to deal and manipulate with non-tabular data from the spreadsheets we will be using\nWhile the purrr package is useful for functional programming, where the type of operation in purrr is to run each step sequentially, the furrr package makes it incredibly easy to improve performance by running the steps concurrently.\n\n\nlibrary(tidyxl)\nlibrary(tibble)\nlibrary(dplyr)\nlibrary(purrr)\nlibrary(furrr); plan(multicore)\nlibrary(unpivotr) # https://nacnudus.github.io/unpivotr/\n\n\n\nCreating Function\nCreation of an extract sheets function. First, the function extracts the rows and columns in the spreadsheet that has the data types: character(string), numeric and logical (boolean) and displays the cells as though in a spreadsheet(rectify function) and afterwards the function filters the table. Next, we create the headings for our table and we set the names for each of the columns. Lastly, an if function was created and if the value in the “excl” list is not null, the values will be converted to numeric except the ones in “excl” list. The “excl” is a list of column names that will be chosen later.\n\n\nextract.sheets.f <- function(dsheet, excl=NULL){\n  # inp=dat[1,]$dataset[[1]]\n  # dsheet=filter(inp, sheet==\"cost_capital\" )\n  out <- dsheet %>% \n    select(row, col, data_type, character, numeric, logical) %>% \n    rectify %>% # https://rdrr.io/cran/unpivotr/man/rectify.html\n    select(-c(\"row/col\"))\n  nm <- out %>% slice(1) %>% unlist(use.names=FALSE) # headings\n  out <- set_names(out, nm) %>% slice(2:n())\n  # glimpse(out)\n  if (!is.null(excl)){out <- out %>% mutate(across(-excl, as.numeric))}\n  return(out)\n}\n\n\n\nCreating list paths\nThe creation of all the xlxs paths in the xlsx folder. For example: \"“./data/xlsx/singapore_advertising.xlsx”\n\n\nlist_paths <- list.files(\n  path = file.path(path_xlsx),\n  pattern = \".xlsx\",\n  full.names = TRUE\n)\n\n\n\n#Creating dat First line of codes actually creates a sector column and the relevant names by removing the “.xlsx” and “./data/xls/” in the list_paths. Second line of codes maps the path with the import cells function from an xlsx file to create a 3rd column dataset that contains all the cells in the xlxs files. Afterwards, set the names of the vector from the sector column.\n\n\ndat=enframe(list_paths, name = NULL, value = \"path\") %>%\n  mutate(sector=gsub(\".xlsx\", \"\", basename(path)))\n\ndat=dat %>% # slice(1:2) %>%\n  mutate(\n    dataset=future_map(path, xlsx_cells) %>% \n      set_names(sector)\n  )\n\n\n\nSingapore industries\nChanges across different groups of sectors have implications for how businesses should be run as well how investors value these Singaporean companies.\nA new dataframe, singapore_industries, is created. The dataset column in dat is mapped to the earnings_debt cell sheet using the extract.sheets.f function. This creates a row with the columns country, company_name, industry_group and the relevant earnings_debt column names and the relevant data associated with it.\nCreated a list called “excl” with contains country, company_name, industry_group. The first row of probably contains the summary of each industry and hence, it will be sliced. The first row of each industry is sliced and binded together, arranged by industry_group in ascending order and the roic_cost_capital is arranged in descending order in each industry_group.\n\n\nexcl=c(\"country\", \"company_name\", \"industry_group\")\nsingapore_industries=future_map(\n  dat$dataset,\n  function(inp){\n    extract.sheets.f(dplyr::filter(inp, sheet==\"earnings_debt\"), all_of(excl)) %>%\n      slice(1)\n  }\n) %>% \n  bind_rows(.) %>% \n  arrange(industry_group) %>%\n  arrange(desc(roic_cost_capital))\n\nhead(singapore_industries)\n\n\n\nSingapore earnings debt\nWe could also argue that these hurdle rates - cost of debt & cost of equity - represent benchmarks that companies have to beat to create value. That said, many Singaporean companies measure success using lower thresholds, with some arguing that making money (having positive profits) is good enough and others positing that being more profitable than competitors in the same business makes a firm a good company. However, without considerations given to cost of capital, returns are only half the picture. After all, capital is invested in businesses and that capital invested elsewhere in equivalent risk investments could have earned a return. The composite measure of excess returns is what we estimate here.\nExactly same as the above code for Singapore Industries, with the difference of slicing every row other than the first row. The sliced rows is then arranged by industry_group and afterwards in each row of the industry_group category, the rows are arranged in descending order by the roic_cost_capital.\n\n\nsingapore_earnings_debt=future_map(\n  dat$dataset,\n  function(inp){\n    extract.sheets.f(dplyr::filter(inp, sheet==\"earnings_debt\"), all_of(excl)) %>%\n      slice(2:n())\n  }\n) %>% \n  bind_rows(.) %>% \n  arrange(industry_group) %>%\n  arrange(industry_group, desc(roic_cost_capital))\n\nif (FALSE){\n  singapore_earnings_debt %>%\n    dplyr::filter(dividend_yield>0.05) %>%\n    group_by(industry_group) %>%\n    slice(1)\n} #This line of code never executes. \n\nhead(singapore_earnings_debt)\n\n\n\nCost of capital for Singapore companies\nThe cost of capital is a ubiquitous metric for corporate executives, to maximize the value of the business(firm), because it: - drives investing decisions - helps determine financing choices - affects dividend policy and valuations.\nWhile the conventional cost of capital approach is built around the assumption that the operating income of a company is unaffected by its debt policy, a simple extension would allow the operating income to change (dropping as a company’s default risk increases) and the optimal debt ratio then would be the one that maximizes firm value (rather than minimize cost of capital).\nPut differently, if we accept the argument that some Singaporean companies can borrow too much and others too little, it follows that there is an optimal mix of debt and equity for a business and the only question is how we determine that optimal.\nThe complications with estimating the optimal capital structure lie in two aspects: - in the statistical problems with estimating risk parameters - with the financial models built on these parameters.\nThere is a way of estimating costs of equity and capital that is agnostic about the choice of models, but it leads to circular reasoning, at least in the context of valuation. Here, the cost of capital operates as an optimizing engine where the price of risk is set by markets, and it enters the cost of capital in two places. When estimating the cost of equity, it manifests as an equity risk premium, and in the cost of debt computation, it is a default spread. Both are set by markets, reflect investor risk aversion and change over time.\nThe code below provides a table for updated cost of capital, target debt ratios (optimal financing mix) for a total of 306 Singaporean companies, and what each company can sustain in debt as we change the current debt to capital ratio to a target debt ratio. To estimate the cost of capital at different debt ratios, we used data from trusted data vendors including S&P Capital IQ, Bloomberg, and a host of specialized data sources inside 162 Grid.\nCreating the singapore_cost_capital dataframe. Slicing the dataset from dat, if the number of unique sheets is greater than 1, the extract.sheets.f will be performed and it will and the dataset column in dat is mapped to the cost_capital cell sheet. This creates a row/rows (from each xls) with the column names company_name, exchange_ticket, industry_group, country, actual_debt_rating, optimal_debt_rating, flag_bankruptcy, flag_refinanced and the relevant cost_capital column names with all the data.\nEach row is then binded together and a new column called spread_optimal is created by using actual_debt_capital - optimal_debt_capital columns. Afterwards, the rows are arranged by industry_group in ascending order and the spread_optimal is arranged in ascending order in each industry_group.\n\n\nexcl=c(\"company_name\", \"exchange_ticker\", \"industry_group\", \"country\", \n       \"actual_debt_rating\", \"optimal_debt_rating\", \"flag_bankruptcy\", \n       \"flag_refinanced\") #New excl list\n\nsingapore_cost_capital=future_map(\n  dat$dataset,\n  function(inp){\n    if ( (inp$sheet %>% n_distinct) > 1){\n      extract.sheets.f(dplyr::filter(inp, sheet==\"cost_capital\"), all_of(excl))\n    }\n  }\n) %>% \n  bind_rows(.) %>%\n  mutate(spread_optimal=actual_debt_capital-optimal_debt_capital) %>% \n  arrange(industry_group, spread_optimal)\n\nhead(singapore_cost_capital)\n\n\n\nSingapore screener\nA singapore_screener dataframe is created. The industry_group, company_name, dividend_yield, roe, cost_equity, roe_excess_return=roe_cost_equity, roic, cost_capital, roic_excess_return=roic_cost_capital was selected from the singapore_earnings_debt dataframe. A left join was conducted with the singapore_earnings_debt and singapore_cost_capital on “company_name”.\nThe joined table will then contain the columns industry_group, company_name, dividend_yield, roe, cost_equity, roe_excess_return, roic, cost_capital, roic_excess_return, actual_debt_capital, optimal_debt_capital and spread_optimal.\nThe newly joined table’s following columns are then selected: company_name, dividend_yield, roic_excess_return, roic, cost_capital, roe_excess_return, roe, cost_equity, spread_optimal, actual_debt_capital, optimal_debt_capital and filtered with the following conditions: dividend_yield>0.01, roic_excess_return>0.025, spread_optimal<0.\n\n\nsingapore_screener=singapore_earnings_debt %>%\n  select(industry_group, company_name, dividend_yield, roe, cost_equity, roe_excess_return=roe_cost_equity, roic, cost_capital, roic_excess_return=roic_cost_capital) %>%\n  left_join(\n    singapore_cost_capital %>% select(company_name, actual_debt_capital, optimal_debt_capital, spread_optimal)\n  ) %>%\n  select(company_name, dividend_yield, roic_excess_return, roic, cost_capital, \n         roe_excess_return, roe, cost_equity, spread_optimal, actual_debt_capital, optimal_debt_capital) %>%\n  dplyr::filter(dividend_yield>0.01, roic_excess_return>0.025, spread_optimal<0)\n\nhead(singapore_screener)\n\nif (FALSE){\n  singapore_db=future_map(\n    dat$dataset,\n    function(inp){\n      excl=c(\"country\", \"company_name\", \"industry_group\")\n      out=list(earnings_debt=extract.sheets.f(dplyr::filter(inp, sheet==\"earnings_debt\"), all_of(excl)))\n      if ( (inp$sheet %>% n_distinct) > 1){\n        excl=c(\"company_name\", \"exchange_ticker\", \"industry_group\", \"country\", \n               \"actual_debt_rating\", \"optimal_debt_rating\", \"flag_bankruptcy\", \n               \"flag_refinanced\")\n        out=update_list(\n          out, \n          cost_capital=extract.sheets.f(dplyr::filter(inp, sheet==\"cost_capital\"), all_of(excl))\n        )\n        \n        nm=inp %>%\n          select(sheet) %>%\n          distinct(.) %>%\n          dplyr::filter(!sheet %in% c(\"earnings_debt\", \"cost_capital\")) %>%\n          pull\n        \n        out=update_list(\n          out, \n          optimal_mix=map(\n            nm,\n            ~extract.sheets.f(dplyr::filter(inp, sheet==.x), NULL)\n          ) %>%\n            set_names(nm)\n        )\n      }\n      out\n    }\n  )\n  #This line of code never executes. \n}\n\n\n\nSaving Rda file\nThe following dataframes are then saved into “singapore_fundamental_data.Rda”\n\n\nsave(singapore_industries, singapore_earnings_debt, singapore_cost_capital, singapore_screener, file=file.path(path_data, \"singapore_fundamental_data.Rda\"))\n\n\n\n\n\n\n",
      "last_modified": "2021-10-30T22:34:59+08:00"
    }
  ],
  "collections": []
}
